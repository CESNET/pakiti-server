<?php
# Copyright (c) 2017, CESNET. All rights reserved.
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following
# conditions are met:
#
#   o Redistributions of source code must retain the above
#     copyright notice, this list of conditions and the following
#     disclaimer.
#   o Redistributions in binary form must reproduce the above
#     copyright notice, this list of conditions and the following
#     disclaimer in the documentation and/or other materials
#     provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

/**
 * @author Michal Prochazka
 */
class VulnerabilityDao
{
    private $db;

    public function __construct(DbManager &$dbManager)
    {
        $this->db = $dbManager;
    }

    /*******************
     * Public functions
     *******************/

    /*
     * Stores the vulnerability in the DB
     */
    public function create(Vulnerability &$vulnerability)
    {
        $this->db->query(
            "insert into Vulnerability set
      	operator='" . $this->db->escape($vulnerability->getOperator()) . "',
      	cveDefId=" . $this->db->escape($vulnerability->getCveDefId()) . ",
      	osGroupId=" . $this->db->escape($vulnerability->getOsGroupId()) . ",
      	name=" . $this->db->escape($vulnerability->getName()) . ",
      	version=" . $this->db->escape($vulnerability->getVersion()) . ",
      	release=" . $this->db->escape($vulnerability->getRelease()) . ",
      	arch=" . $this->db->escape($vulnerability->getArch())
        );

        # Set the newly assigned id
        $vulnerability->setId($this->db->getLastInsertedId());
    }

    public function getVulnerablePkgs($hostId, $osGroupsIds, $orderBy, $pageSize, $pageNum)
    {
        if(empty($osGroupsIds)){
            return array();
        }

        $sql = "select distinct Pkg.id as _id, Pkg.name as _name, Pkg.version as _version, Pkg.release as _release, Pkg.arch as _arch
                from InstalledPkg join PkgCveDef on InstalledPkg.pkgId = PkgCveDef.pkgId join Pkg
                on Pkg.id = InstalledPkg.pkgId  where InstalledPkg.hostId={$hostId}
                and PkgCveDef.osGroupId in (" . implode(",", array_map("intval", $osGroupsIds)) . ")";

        switch ($orderBy) {
            case "arch":
                $sql .= " order by Pkg.arch";
                break;
            case "version":
                $sql .= " order by Pkg.version, Pkg.release";
                break;
            default:
                // oderByName by default
                $sql .= " order by Pkg.name";
        }

        if ($pageSize != -1 && $pageNum != -1) {
            $offset = $pageSize * $pageNum;
            $sql .= " limit $offset,$pageSize";
        }

        $vulnerablePkgs = $this->db->queryObjects($sql, "Pkg");

        return $vulnerablePkgs;


    }

    public function getVulnerablePkgsByPkgsIdsAndOsGroupsIds($pkgsIds, $osGroupsIds)
    {
        if(empty($pkgsIds) || empty($osGroupsIds)){
            return array();
        }
        $sql = "select Pkg.id as _id, Pkg.name as _name, Pkg.version as _version, Pkg.release as _release, Pkg.arch as _arch
            from Pkg inner join PkgCveDef on Pkg.id = PkgCveDef.PkgId
            where PkgCveDef.pkgId in (" . implode(",", array_map("intval", $pkgsIds)) . ")
            and PkgCveDef.osGroupId in (" . implode(",", array_map("intval", $osGroupsIds)) . ")";
        $vulnerablePkgs = $this->db->queryObjects($sql, "Pkg");
        return $vulnerablePkgs;
    }

    /*
     * Stores multiple vulnerabilities, using insert ignore to avoid errors during duplicates
     */
    public function createMultiple(&$vulnerabilities)
    {
        # If vulnerabilities is not an array, then quit
        if (!is_array($vulnerabilities)) return;
        $sql = 'insert ignore into Vulnerability (`name`, version, `release`, `arch`, operator, `cveDefId`, osGroupId) values ';
        $firstEntry = true;
        foreach ($vulnerabilities as $vuln) {
            # Do not add comma before first entry
            if ($firstEntry) {
                $firstEntry = false;
            } else {
                $sql .=',';
            }
            $sql .= "('".$vuln->getName()."', '".$vuln->getVersion()."','".$vuln->getRelease()."', '".$vuln->getArch()."', '".$vuln->getOperator()."',".
                $vuln->getCveDefId().',' .$vuln->getOsGroupId().')';
        }
        $this->db->query($sql);
    }

    /*
     * Get the vulnerability by its ID
     */
    public function getById($id)
    {
        if (!is_numeric($id)) return null;
        return $this->db->queryObject(
            "select
    		id as _id, name as _name, version as _version, release as _release, arch as _arch, operator as _operator, cveDefId as _cveDefId,
		osGroupId as _osGroupId
      from 
      	Vulnerability 
      where
      	id=" . $this->db->escape($id)
            , "Vulnerability");
    }



    /*
     * Update the vulnerability in the DB
     */
    public function update(Vulnerability &$vulnerability)
    {
        $this->db->query(
            "update Vulnerability set
      	operator='" . $this->db->escape($vulnerability->getOperator()) . "',
      	cveDefId=" . $this->db->escape($vulnerability->getCveDefId()) . ",
      	osGroupId=" . $this->db->escape($vulnerability->getOsGroupId()) . ",
      	name='" . $this->db->escape($vulnerability->getName()) . "',
      	version='" . $this->db->escape($vulnerability->getVersion()) . "',
      	`release`='" . $this->db->escape($vulnerability->getRelease()) . "',
      	arch='" . $this->db->escape($vulnerability->getArch()) . "'
      where id=" . $this->db->escape($vulnerability->getId()));
    }

    /*
     * Delete the vulnerability from the DB
     */
    public function delete(Vulnerability &$vulnerability)
    {
        $this->db->query(
            "delete from Vulnerability where id=" . $vulnerability->getId());
    }

    /*
     * Get Vulnerabilities by CveDefs Ids (array) and Os Id
     * @param Vulnerability $vulnerability
     */
    public function getVulnerabilitiesByCveDefsIdsAndOsGroupId($cveDefsIds, $osGroupsIds)
    {
        if(empty($cveDefsIds) || empty($osGroupsIds)){
            return array();
        }
        return $this->db->queryObjects(
            "select
    		id as _id, name as _name, version as _version, arch as _arch, `release` as _release,
    		osGroupID as _osGroupID, operator as _operator, cveDefId as _cveDefId
      from
      	Vulnerability
      where
       cveDefId IN (" . implode(",", array_map("intval", $cveDefsIds)) . ") and osGroupId in (" . implode(",", array_map("intval", $osGroupsIds)) . ")", "Vulnerability");
    }

    /**
     * Return array of Vulnerabilities for a specific Package name, Os Group and Arch name
     * @param $name
     * @param $osGroupId
     * @param $arch
     * @return array
     */
    public function getVulnerabilitiesByPkgNameOsGroupIdArch($name, $osGroupsIds, $arch)
    {
        if(empty($osGroupsIds)){
            return array();
        }
        $sql = "select Vulnerability.id as _id, Vulnerability.name as _name, Vulnerability.version as _version,
                Vulnerability.release as _release, Vulnerability.arch as _arch, Vulnerability.osGroupId as _osGroupId,
                Vulnerability.operator as _operator, Vulnerability.cveDefId as _cveDefId
                from Vulnerability where Vulnerability.name='" . $this->db->escape($name) . "'
                and Vulnerability.osGroupId in (" . implode(",", array_map("intval", $osGroupsIds)) . ") and (Vulnerability.arch='all' or Vulnerability.arch='" . $this->db->escape($arch) . "')";

        # Create objects
        $vulnerabilities = $this->db->queryObjects($sql, "Vulnerability");

        if ($vulnerabilities == null) {
            $vulnerabilities = array();
        }
        return $vulnerabilities;
    }

    /**
     * Return array of Vulnerabilities for a specific Package name and arch
     * @param $name
     * @return array
     */
    public function getVulnerabilitiesByPkgNameArch($pkgName, $pkgArch)
    {
        $sql = "select id as _id, name as _name, version as _version,
                `release` as _release, arch as _arch, osGroupId as _osGroupId,
                operator as _operator, cveDefId as _cveDefId from Vulnerability 
                where name='" . $this->db->escape($pkgName) . "' and (Vulnerability.arch='all' or Vulnerability.arch='" . $this->db->escape($pkgArch) . "')";

        # Create objects
        $vulnerabilities = $this->db->queryObjects($sql, "Vulnerability");

        if ($vulnerabilities == null) {
            $vulnerabilities = array();
        }
        return $vulnerabilities;
    }
}
?>
